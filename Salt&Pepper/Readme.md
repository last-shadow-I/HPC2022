# SaltPepper
*Данная лабораторная работа заключается в реализации медианного фильтра для обработки изображения*
* Лабораторная представлена 2 файлами: .cu и make
* Также для работы требуются файлы библиотеки EasyBMP для работы с файлами BMP
* В файле .cu содержится код хоста, функция для последовательной обработки и функция ядра
* make файл используется для компоновки .cu и файлов библиотеки
* После компоновки, используя команду *make* код запускается с помощью команды *./SP 1й_арг 2й_арг
* 1й_арг, 2й_арг это проценты обработки по 1й и 2й координате соответсвенно (от 0 до 1)

##### .cu устроен так: 
1. Вначале идут реализации функций (функции медианного фильтра и последовательного прохода окна для последовательной обработки и функция ядра)
2. После инициализации процентов обработки создаётся и инициализируется объект хранящий данные обрабатываемого изрбражения
3. Создаётся вектор векторов ***a***, который обрабатывается так чтобы изображение было в его центре, а по краям были копированные данные из границ изображение
4. Создаётся одномерный массив ***h_data***, который хранит только данные изображения
5. Создаётся cudaChannelFormatDesc, который хранит информацию об канале для cudaArray_t
6. С помощью cudaMallocArray и cudaMalloc выделяется память под соответсвующие массивы.
7. Создаётся cudaArray_t для дальнейшего его преобразрвания в текстуру и массив arrayOutput для записи на видеокарте полученных данных
8. Создаются объекты хранящие настройки текстуры: resDesc - хранит где размещены данные текстуры и тип массива, texDesc хранит информацию о доступу к элементам текстуры
9. Создаётся объект текстуры, создаются ивенты для дальнейшего замера времени
10. Засекается время старта, вызывается функция ядра, синхронизируются CPU и GPU, засекается время конца
15. Массив arrayOutput копируется с GPU на CPU в h_data
16. Производится замер времени, вызов функции для последовательной обработки, замер времени
17. Выводятся время работы каждой функции
18. Очищается память  
##### функция ядра устроена так:
1. Используется виртуальная архитектура CUDA для вычисления 1го и 2го индекса каждой нити 
2. Каждая нить объявляет массив в регистровой памяти
3. Чтобы не записывались "неправильные" данные ограничиваются индексы у нитей
4. Каждая нить заполняет массив данными из текстуры с помощью tex2D<float>()
5. Каждая нить выполняет пузырьковую сортировку
6. В arrayOutput записывается 5 элемент(4 индекс)
  
* Входное изображение
![](input.bmp)
* Выходное изображение CPU c процентами обработки 0.5 и 1
![](outputCPU(0.5,1).bmp)
* Выходное изображение GPU c процентами обработки 0.5 и 1
![](outputGPU(0.5,1).bmp)
* Данные времени выполнения на 5200 пикселей
![](image.png)
* Данные времени выполнения на 104 800 пикселей
![](image1.png)
* Видно что ускорение почти линейно 
##### Баг или фича
* Почему-то функция ядра нормально работает только с квадратными картинками
* В случаем прямоугольных она делает наслоени исходной картинки, даже если нитей выделяется меньше размера картинки.
* Если закоментировать сортировку он возвращает исходную картинку( даже прямоугольную)
* При добавлении сортировки на прямоугольных изображениях всё ломается. Я думал из-за хранения данных в текстуре по Fortran'у( в столбцы) (Как долго я думал пчм не так идёт получение данных). Но нет, без сортировкм всё нормально
