# SumVect
*Данная лабораторная работа заключается в реализации поэлементного сложения двух векторов используя программно-аппаратную архитектуру CUDA*
* Лабораторная представлена 3 файлами: .h .cu и make
* В файле .cu содержится функция ядра
* В файле .h содержится код хоста и функция для последовательного сложения 2х векторов
* make файл используется для компоновки и представляет собой файл с флагами
* После компоновки, используя команду *make* код запускается с помощью команды *./Add 1й_арг 2й_арг 3й_арг 4й_арг 5й_арг*
* 1й_арг - длина векторов
* 2й_арг и 3й_арг это количество нитей в блоке и количество блоков в гриде соответсвенно
* 4й_арг флаг автозаполнения матриц, а 5й_арг максимальный порог выводимых результатов в консоль

##### .h устроен так: 
1. После инициализации размерности определяется количество нитей в блоке и количество блоков в гриде ( не меньше 1)
2. Выделяется память под 4 массива: A, B, CGPU, CCPU
3. Происходит инициализация массивов (либо автоматически, либо ввод с консоли)
4. Выделяется память на GPU, создаются ивенты для дальнейшего замера времени
5. Копируются массивы с хоста на девайс в их аналоги
6. Засекается время старта, вызывается функция ядра, синхронизируются CPU и GPU, засекается время конца
7. Массив С копируется с GPU на CPU
8. Производится замер времени, вызов функции для последовательного умножения, замер времени
9. Выводятся время работы каждой функции, а также максимум модуля разности между CGPU и CCPU, и ускорение
10. Очищается память 
 
##### .cu устроен так: 
1. Используется виртуальная архитектура CUDA для вычисления количества выделенных нитей и индекса для каждой нити
2. Каждая нить начинает вычислять значение вектора C со своего индекса, при этом после вычисления одного элемента, нити выдаётся 2й индекс, который она вычисляет если он не вышел за размер вектора
3. ПРи такой реализации значение сложения векторов вычисляются при любом количестве выделенных ниете

##### В excele находятся данные измерений
* Проведены два вычислительных эксперимента:
1. Вычислено ускорение в зависимости от размерности задачи. Получено, что с возрастанием размерности задачи ускорение растёт.
2. Вычислено ускорение в зависимости от количества нитей выделенных на задачу одной размерности. Получено, что выделение новых нитей рентабельно только до определённого предела, после которого ускорение падает. Сделан вывод, что после этого предела время выделения новых нитей больше, чем время на выполнение операций
* Также представлены несколько примеров запуска кода
